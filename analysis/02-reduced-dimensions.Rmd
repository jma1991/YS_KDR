---
title: "Dimensionality reduction"
author: "James Ashmore"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Motivation

In this document we aim to reduce the number of separate dimensions in the data by performing dimenstionality reduction.

## Setup

Set chunk options:

```{r}
knitr::opts_chunk$set(
  autodep    = TRUE,
  cache      = TRUE,
  cache.path = "cache/02-reduced-dimensions.Rmd/",
  dev        = "png",
  error      = FALSE,
  message    = FALSE,
  warning    = FALSE
)
```

Load Biocoductor packages:

```{r}
library(scater)
library(scran)
library(scuttle)
```

Load CRAN packages:

```{r}
library(ggforce)
library(patchwork)
```

Read experiment data:

```{r}
sce <- readRDS("output/01-batch-integration.rds")
```

## PCA

Cluster cells to help examine separation of clusters by principal components:

```{r}
snn <- buildSNNGraph(sce, use.dimred = "corrected")

com <- igraph::cluster_walktrap(snn)

sce$cluster.temp <- factor(com$membership)
```

### Elbow

Find the elbow point in the percentage of variance explained by successive PCs:

```{r}
var <- metadata(sce)$pca.info$var.explained / metadata(sce)$pca.info$var.total

num <- RclusTool::ElbowFinder(seq_along(var), var)
```

Plot the percentage of variance explained by successive PCs:

```{r}
dat <- data.frame(index = seq_along(var), total = var)

ggplot(dat, aes(index, total)) +
  geom_point() +
  geom_vline(xintercept = num, colour = "red") +
  labs(x = "PC", y = "Variance (%)") +
  scale_x_continuous(n.breaks = 10, limits = c(0, NA)) +
  scale_y_continuous(n.breaks = 10, limits = c(0, NA)) +
  theme_minimal()
```

### Structure

Find the number of subpopulations in the data using clustering:

```{r}
dim <- reducedDim(sce, "corrected")

fit <- getClusteredPCs(dim, min.rank = 1, max.rank = 50)

num <- metadata(fit)$chosen
```

Plot the percentage of variance explained by successive PCs:

```{r}
dat <- as.data.frame(fit)

ggplot(dat, aes(n.pcs, n.clusters)) +
  geom_point() +
  geom_abline(slope = 1, intercept = 1, colour = "red") +
  geom_vline(xintercept = num, colour = "grey", linetype = "dashed") +
  labs(x = "PC", y = "Number of clusters") +
  theme_minimal()
```

### Selection

Choose number of PCs to retain from the above analyses:

```{r}
idx <- seq_len(5)

reducedDim(sce, "corrected") <- reducedDim(sce, "corrected")[, idx]
```

Plot scatter matrix of retained PCs:

```{r fig.height = 8, fig.width = 10}
plotReducedDim(sce, "corrected", colour_by = "cluster.temp", ncomponents = length(idx)) + theme(legend.position = "none")
```

Cluster cells to help examine effect of TSNE and UMAP hyper-parameters:

```{r}
snn <- buildSNNGraph(sce, use.dimred = "corrected")

com <- igraph::cluster_walktrap(snn)

sce$cluster.temp <- factor(com$membership)
```

## TSNE

Perform t-stochastic neighbour embedding (t-SNE) on the PCA data.

### Parameter exploration

Inspect TSNE plots generated by different perplexity and iteration parameters:

```{r fig.height = 10, fig.width = 10}
lim <- (ncol(sce) - 1) / 3

max <- ifelse(lim < 50, lim, 50)

per <- seq(5, max, length.out = 6)

itr <- seq(500, 1500, length.out = 6)

arg <- expand.grid(
  perplexity = floor(per),
  max_iter = floor(itr)
)

plt <- apply(arg, 1, function(x) {

  set.seed(1101000110)

  run <- runTSNE(sce, dimred = "corrected", perplexity = x[1], max_iter = x[2])

  txt <- paste(x[1], x[2], sep = "/")

  plotTSNE(run, colour_by = "cluster.temp") + 
    ggtitle(txt) + 
    theme_no_axes() + 
    theme(aspect.ratio = 1, axis.title = element_blank(), legend.position = "none")

})

wrap_plots(plt, nrow = 6, ncol = 6, byrow = FALSE)
```

### Calculate TSNE

Select optimal perplexity value and number of iterations:

```{r}
set.seed(1101000110)

sce <- runTSNE(sce, dimred = "corrected", perplexity = 32, max_iter = 1500)
```

## UMAP

Perform uniform manifold approximation and projection (UMAP) on the PCA data.

### Parameter exploration

Inspect UMAP plots generated by different neighbors and distance parameters:

```{r fig.height = 10, fig.width = 10}
max <- ifelse(ncol(sce) < 100, ncol(sce), 100)

num <- seq(2, max, length.out = 6)

dst <- seq(0, 1, length.out = 6)

arg <- expand.grid(
  n_neighbors = floor(num),
  min_dist = signif(dst, digits = 2)
)

plt <- apply(arg, 1, function(x) {

  set.seed(0000100110)

  run <- runUMAP(sce, dimred = "corrected", n_neighbors = x[1], min_dist = x[2])

  txt <- paste(x[1], x[2], sep = "/")

  plotUMAP(run, colour_by = "cluster.temp") + 
    ggtitle(txt) + 
    theme_no_axes() + 
    theme(aspect.ratio = 1, axis.title = element_blank(), legend.position = "none")

})

wrap_plots(plt, nrow = 6, ncol = 6, byrow = FALSE)
```

### Calculate UMAP

Select optimal number of nearest neighbors:

```{r}
set.seed(0000100110)

sce <- runUMAP(sce, dimred = "corrected", n_neighbors = 41, min_dist = 0.6)
```

## Variables {.tabset}

### PCA

```{r, fig.height = 8, fig.width = 10}
var <- c("sum", "detected", "subsets_MT_percent", "subsets_EGFP_percent")

plt <- lapply(var, function(x) plotReducedDim(sce, "corrected", colour_by = x) + theme_no_axes() + coord_fixed(1))

patchwork::wrap_plots(plt, ncol = 2)
```

### TSNE

```{r, fig.height = 8, fig.width = 10}
var <- c("sum", "detected", "subsets_MT_percent", "subsets_EGFP_percent")

plt <- lapply(var, function(x) plotTSNE(sce, colour_by = x) + theme_no_axes() + theme(aspect.ratio = 1))

patchwork::wrap_plots(plt, ncol = 2)
```

### UMAP

```{r, fig.height = 8, fig.width = 10}
var <- c("sum", "detected", "subsets_MT_percent", "subsets_EGFP_percent")

plt <- lapply(var, function(x) plotUMAP(sce, colour_by = x) + theme_no_axes() + theme(aspect.ratio = 1))

patchwork::wrap_plots(plt, ncol = 2)
```

## Summary

### Output

Remove temporary clustering:

```{r}
sce$cluster.temp <- NULL
```

Save experiment object to disk:

```{r output}
saveRDS(sce, file = "output/02-reduced-dimensions.rds")
```

### Session

Print session information:

```{r}
sessionInfo()
```
